{"ast":null,"code":"import { initializeApp } from \"firebase/app\"; // um die app Instanz zu starten\n//importiere die authentification library von firebase --- wird für das google sign in benötigt (entweder per popup oder redirect)\n\nimport { getAuth, signInWithRedirect, signInWithPopup, GoogleAuthProvider, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged } from \"firebase/auth\";\nimport { getFirestore, // firestore instanz starten\ndoc, // Zugriff auf document type in firebase (user)\ngetDoc, // get document data in firebase (for each user)\nsetDoc, // set document data in firebase (for each user)\ncollection, writeBatch, // make sure that all objects we want to add to the collection are successfully added\nquery, // iteriert durch firestore collection\ngetDocs // gibt die documents aus firestore wieder\n} from \"firebase/firestore\"; // Your web app's Firebase configuration von der Firebase Webseite. Das sind die Konfiguaraionsdaten zu diese speziellen Projekt\n\nconst firebaseConfig = {\n  apiKey: \"AIzaSyDiOjfAzd3SJXJvyGP2rhEb3oLWgC8Z94o\",\n  authDomain: \"test-shop-6668c.firebaseapp.com\",\n  projectId: \"test-shop-6668c\",\n  storageBucket: \"test-shop-6668c.appspot.com\",\n  messagingSenderId: \"634615670222\",\n  appId: \"1:634615670222:web:29da64eb32dc34fef4379f\"\n}; // Initialize Firebase // SDK (Developer Kit)\n\nconst firebaseApp = initializeApp(firebaseConfig); // initialzie a provider / provider ist also immer eine neue Instanz von googleauthprovider (hat constructor und benotigt Argumente)\n// googleAuthProvider ist eine Klasse, die connected mit googleAuth ist. Deswegen new Keyword für neue Instanz\n// Und manchmal müssen wir mehrer verschiedene Provider erstellen, um verschiedene Daten zu bearbeiteten\n// man könnte zum Beispiel für signInWithRedirect einen anderen Provider mitgeben\n\nconst provider = new GoogleAuthProvider(); // dann geben wir diesem Provider noch spezielle Instruktionen, wie er vorgehen soll / Ich denke mal, jeder User der dann den Provider nutzt, interagiert mit dieser überarbeiteteten\n// Version, da diese erst initialisiert wurde, jetzt angepasst und später aufgerufen wird\n\nprovider.setCustomParameters({\n  prompt: \"select_account\" // jedes Mal, wenn jemand mit dem Provider interagiert, soll er jedes mal seinen account auswählen müssen\n\n}); // Google will diese Einstellung/ Vorgehen und man muss es einfach wissen, dass man es so einstellen muss\n// diese authentification wird woanders eingebunden\n// Authentification Prozess ist immer gleich. Das ist keine Klasse, von der Unterschiedliche Objekte erstellt werden müssen\n// deswegen kein new Keyword\n\nexport const auth = getAuth(); // ebenso müssen wir die Signin Logik woanders einbinden (button in SignIn Sektion) und als Parameter bekommt er einmal die authentification und den Provider\n\nexport const signInWithGooglePopup = () => signInWithPopup(auth, provider); // Man braucht immer nur eine Authentification, egal für welchen Vorgang aber man könnte verschiedene Provider Konfiguraitionen für verschiedene Services benötigen\n// (   Deswegen bei getAuth() kein new keyword und bei    new GoogleAuthProvider() mit new Keyword   )\n// ab hier werden die Daten dann angelegt bzw in firestore gespeichert\n\nexport const db = getFirestore(); // die hier geschaffene Instanz gibt uns 1mal acces zur Database jedes mal um etwas zu ändern?\n\nexport const addCollectionAndDocuments = async (collectionKey, objectsToAdd) => {\n  // async case we call a database to store data\n  const collectionRef = collection(db, collectionKey);\n  const batch = writeBatch(db); //instaziate a batch class\n\n  objectsToAdd.forEach(object => {\n    //es gibt 5 verschiedene Objekte in unsere shopdata.js file\n    const docRef = doc(collectionRef, object.title.toLowerCase());\n    batch.set(docRef, object);\n  });\n  await batch.commit();\n  console.log(\"artikel hochgeladen\");\n};\nexport const getCategoriesAndDocuments = async () => {\n  const collectionRef = collection(db, \"categories\");\n  const q = query(collectionRef);\n  const querySnapshot = await getDocs(q); // getDocs fetches document snapshots\n\n  querySnapshot.docs; // gives a query snapshot of an array   ; ; \n}; // hier wollen wir die Daten, die wir von dem authentification service aus signIn Component zurückerhalten(nach sign in) übergeben\n// und dann inside firestore speichern\n\nexport const createUserDocumentFromAuth = async function (userAuth) {\n  let additionalInformation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // in additional information wird wegen unten genannt, der displayname übergeben {displayName: \"mike\"}\n  // prüfen, ob eine bestiimte Instanz vom document user bereits existiert (Referenz)\n  // die Methode doc() nimmt drei argumente:\n  // die Datenbank, die aufgerufen werden soll(firestore)\n  // wie die entsprechende collection heißt (der folder) hier: users\n  // der Unique identifier für den entsprechenden user (das document) -> hier übergeben wir aus dem auth service die \"uid\"\n  const userDocRef = doc(db, \"users\", userAuth.uid); // console.log(userDocRef)\n  // Bis hier hin, wird nach user login vom shop ein \"leerer\" Befehl mit user/userId an die Datenbank geschickt, weil noch nicht \n  // definiert wurde, wie die Daten verarbeitet werden sollen/ bzw. welche Daten abgefragt und gespeichert werden\n  // mit getDoc versucht man die Daten zu einem Document zu erfassen. Also übergeben wir dem die user data von firestore, vom user der sich gerade authentifiziert hat\n  // snapshot ist quasi die Dateien und ist auch ein SPEZIELLES OBJEKT\n\n  const userSnapshot = await getDoc(userDocRef); // console.log(userSnapshot);\n  // console.log(userSnapshot.exists()) // false, weil in meiner firestore database noch kein Eintrag zu diesem user vorhanden ist\n  // now check if user Data exists\n  // create/ set the document with the data from userAuth in my collection\n\n  if (!userSnapshot.exists()) {\n    const {\n      displayName,\n      email\n    } = userAuth; // relevanten Daten aus der userAut response\n\n    const createdAt = new Date(); // aktuelles Datum erfassen\n\n    try {\n      await setDoc(userDocRef, {\n        // Daten in das Document auf firestore eintragen und dabei Folgende Konfigs beachten\n        displayName,\n        email,\n        createdAt,\n        ...additionalInformation // display name wird bisher nicht angezeigt, da google auth das keyword selbst belegt. daher wird dann der name in diesen additional information gespeichert\n\n      });\n    } catch (error) {\n      console.log(\"error creating the user\", error);\n    }\n  }\n\n  return userDocRef;\n}; // INTERFACE LAYER FUNCTIONS\n\nexport const createAuthUserWithEmailAndPassword = async (email, password) => {\n  if (!email || !password) return; // wenn weder email oder passwort agegeben ist, soll diese Funktion nicht ausgeführt werden (protect code)\n\n  return await createUserWithEmailAndPassword(auth, email, password);\n}; // Diese Helper Funktion ist für das log in \n\nexport const signInAuthUserWithEmailAndPassword = async (email, password) => {\n  if (!email || !password) return; // wenn weder email oder passwort agegeben ist, soll diese Funktion nicht ausgeführt werden (protect code)\n\n  return await signInWithEmailAndPassword(auth, email, password);\n};\nexport const signOutUser = async () => signOut(auth); // async weil wir abwarten wollen, was signOut für ein promise returned\n// a callback everytime i want to call when auth state changes\n\nexport const onAuthStateChangedListener = callback => onAuthStateChanged(auth, callback);","map":{"version":3,"sources":["/Users/Bronko/Desktop/capstone/theShop/src/utils/firebase/firebase.utils.js"],"names":["initializeApp","getAuth","signInWithRedirect","signInWithPopup","GoogleAuthProvider","signInWithEmailAndPassword","createUserWithEmailAndPassword","signOut","onAuthStateChanged","getFirestore","doc","getDoc","setDoc","collection","writeBatch","query","getDocs","firebaseConfig","apiKey","authDomain","projectId","storageBucket","messagingSenderId","appId","firebaseApp","provider","setCustomParameters","prompt","auth","signInWithGooglePopup","db","addCollectionAndDocuments","collectionKey","objectsToAdd","collectionRef","batch","forEach","object","docRef","title","toLowerCase","set","commit","console","log","getCategoriesAndDocuments","q","querySnapshot","docs","createUserDocumentFromAuth","userAuth","additionalInformation","userDocRef","uid","userSnapshot","exists","displayName","email","createdAt","Date","error","createAuthUserWithEmailAndPassword","password","signInAuthUserWithEmailAndPassword","signOutUser","onAuthStateChangedListener","callback"],"mappings":"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","sourcesContent":["import { initializeApp } from \"firebase/app\"; // um die app Instanz zu starten\n\n//importiere die authentification library von firebase --- wird für das google sign in benötigt (entweder per popup oder redirect)\nimport { getAuth, signInWithRedirect, signInWithPopup, GoogleAuthProvider, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged } from \"firebase/auth\"\n\nimport {\n    getFirestore,   // firestore instanz starten\n    doc,            // Zugriff auf document type in firebase (user)\n    getDoc,         // get document data in firebase (for each user)\n    setDoc,          // set document data in firebase (for each user)\n    collection,\n    writeBatch,      // make sure that all objects we want to add to the collection are successfully added\n    query,          // iteriert durch firestore collection\n    getDocs         // gibt die documents aus firestore wieder\n} from \"firebase/firestore\";\n\n// Your web app's Firebase configuration von der Firebase Webseite. Das sind die Konfiguaraionsdaten zu diese speziellen Projekt\nconst firebaseConfig = {\n    apiKey: \"AIzaSyDiOjfAzd3SJXJvyGP2rhEb3oLWgC8Z94o\",\n    authDomain: \"test-shop-6668c.firebaseapp.com\",\n    projectId: \"test-shop-6668c\",\n    storageBucket: \"test-shop-6668c.appspot.com\",\n    messagingSenderId: \"634615670222\",\n    appId: \"1:634615670222:web:29da64eb32dc34fef4379f\"\n  };\n  \n  // Initialize Firebase // SDK (Developer Kit)\nconst firebaseApp = initializeApp(firebaseConfig);\n\n  // initialzie a provider / provider ist also immer eine neue Instanz von googleauthprovider (hat constructor und benotigt Argumente)\n  // googleAuthProvider ist eine Klasse, die connected mit googleAuth ist. Deswegen new Keyword für neue Instanz\n  // Und manchmal müssen wir mehrer verschiedene Provider erstellen, um verschiedene Daten zu bearbeiteten\n  // man könnte zum Beispiel für signInWithRedirect einen anderen Provider mitgeben\nconst provider = new GoogleAuthProvider();\n  // dann geben wir diesem Provider noch spezielle Instruktionen, wie er vorgehen soll / Ich denke mal, jeder User der dann den Provider nutzt, interagiert mit dieser überarbeiteteten\n  // Version, da diese erst initialisiert wurde, jetzt angepasst und später aufgerufen wird\nprovider.setCustomParameters({          \n    prompt: \"select_account\"             // jedes Mal, wenn jemand mit dem Provider interagiert, soll er jedes mal seinen account auswählen müssen\n});                                     // Google will diese Einstellung/ Vorgehen und man muss es einfach wissen, dass man es so einstellen muss\n\n\n\n// diese authentification wird woanders eingebunden\n// Authentification Prozess ist immer gleich. Das ist keine Klasse, von der Unterschiedliche Objekte erstellt werden müssen\n// deswegen kein new Keyword\nexport const auth = getAuth();\n\n// ebenso müssen wir die Signin Logik woanders einbinden (button in SignIn Sektion) und als Parameter bekommt er einmal die authentification und den Provider\nexport const signInWithGooglePopup = () => signInWithPopup(auth, provider);\n\n\n// Man braucht immer nur eine Authentification, egal für welchen Vorgang aber man könnte verschiedene Provider Konfiguraitionen für verschiedene Services benötigen\n    // (   Deswegen bei getAuth() kein new keyword und bei    new GoogleAuthProvider() mit new Keyword   )\n\n\n\n// ab hier werden die Daten dann angelegt bzw in firestore gespeichert\n\nexport const db = getFirestore()    // die hier geschaffene Instanz gibt uns 1mal acces zur Database jedes mal um etwas zu ändern?\n\n\nexport const addCollectionAndDocuments = async (collectionKey, objectsToAdd) => {   // async case we call a database to store data\n    const collectionRef = collection(db, collectionKey);\n    const batch = writeBatch(db);        //instaziate a batch class\n\n    objectsToAdd.forEach((object) => { //es gibt 5 verschiedene Objekte in unsere shopdata.js file\n        const docRef = doc(collectionRef, object.title.toLowerCase());\n        batch.set(docRef, object);\n    });\n\n    await batch.commit();\n    console.log(\"artikel hochgeladen\");\n};\n\nexport const getCategoriesAndDocuments = async () => {\n    const collectionRef = collection(db, \"categories\");\n    const q = query(collectionRef);\n\n    const querySnapshot = await getDocs(q);         // getDocs fetches document snapshots\n    querySnapshot.docs     // gives a query snapshot of an array   ; ; \n}\n\n// hier wollen wir die Daten, die wir von dem authentification service aus signIn Component zurückerhalten(nach sign in) übergeben\n// und dann inside firestore speichern\nexport  const createUserDocumentFromAuth = async (userAuth, additionalInformation = {}) => {\n    // in additional information wird wegen unten genannt, der displayname übergeben {displayName: \"mike\"}\n\n    // prüfen, ob eine bestiimte Instanz vom document user bereits existiert (Referenz)\n    // die Methode doc() nimmt drei argumente:\n        // die Datenbank, die aufgerufen werden soll(firestore)\n        // wie die entsprechende collection heißt (der folder) hier: users\n        // der Unique identifier für den entsprechenden user (das document) -> hier übergeben wir aus dem auth service die \"uid\"\n    const userDocRef = doc(db, \"users\", userAuth.uid)\n    // console.log(userDocRef)\n    // Bis hier hin, wird nach user login vom shop ein \"leerer\" Befehl mit user/userId an die Datenbank geschickt, weil noch nicht \n    // definiert wurde, wie die Daten verarbeitet werden sollen/ bzw. welche Daten abgefragt und gespeichert werden\n\n    // mit getDoc versucht man die Daten zu einem Document zu erfassen. Also übergeben wir dem die user data von firestore, vom user der sich gerade authentifiziert hat\n    // snapshot ist quasi die Dateien und ist auch ein SPEZIELLES OBJEKT\n    const userSnapshot = await getDoc(userDocRef);\n    // console.log(userSnapshot);\n    // console.log(userSnapshot.exists()) // false, weil in meiner firestore database noch kein Eintrag zu diesem user vorhanden ist\n\n\n    // now check if user Data exists\n    // create/ set the document with the data from userAuth in my collection\n    if(!userSnapshot.exists()) {\n        const { displayName, email } = userAuth;    // relevanten Daten aus der userAut response\n        const createdAt = new Date();               // aktuelles Datum erfassen\n        \n        try {\n            await setDoc(userDocRef, {              // Daten in das Document auf firestore eintragen und dabei Folgende Konfigs beachten\n                displayName,\n                email,\n                createdAt,\n                ...additionalInformation            // display name wird bisher nicht angezeigt, da google auth das keyword selbst belegt. daher wird dann der name in diesen additional information gespeichert\n            });\n        } catch (error) {\n            console.log(\"error creating the user\", error);\n        }\n    }\n    return userDocRef;\n}\n\n// INTERFACE LAYER FUNCTIONS\n\nexport const createAuthUserWithEmailAndPassword = async (email, password) => {\n    if (!email || !password) return;        // wenn weder email oder passwort agegeben ist, soll diese Funktion nicht ausgeführt werden (protect code)\n\n    return await createUserWithEmailAndPassword(auth, email, password);\n}\n\n// Diese Helper Funktion ist für das log in \nexport const signInAuthUserWithEmailAndPassword = async (email, password) => {\n    if (!email || !password) return;        // wenn weder email oder passwort agegeben ist, soll diese Funktion nicht ausgeführt werden (protect code)\n\n    return await signInWithEmailAndPassword(auth, email, password);\n}\n\nexport const signOutUser = async () =>  signOut(auth);\n// async weil wir abwarten wollen, was signOut für ein promise returned\n\n\n// a callback everytime i want to call when auth state changes\nexport const onAuthStateChangedListener = (callback) => onAuthStateChanged(auth, callback);"]},"metadata":{},"sourceType":"module"}
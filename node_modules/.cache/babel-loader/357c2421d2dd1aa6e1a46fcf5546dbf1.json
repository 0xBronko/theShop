{"ast":null,"code":"import { initializeApp } from \"firebase/app\"; // um die app Instanz zu starten\n//importiere die authentification library von firebase --- wird für das google sign in benötigt (entweder per popup oder redirect)\n\nimport { getAuth, signInWithRedirect, signInWithPopup, GoogleAuthProvider, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged } from \"firebase/auth\";\nimport { getFirestore, // firestore instanz starten\ndoc, // Zugriff auf document type in firebase (user)\ngetDoc, // get document data in firebase (for each user)\nsetDoc // set document data in firebase (for each user)\n} from \"firebase/firestore\"; // Your web app's Firebase configuration von der Firebase Webseite. Das sind die Konfiguaraionsdaten zu diese speziellen Projekt\n\nconst firebaseConfig = {\n  apiKey: \"AIzaSyDiOjfAzd3SJXJvyGP2rhEb3oLWgC8Z94o\",\n  authDomain: \"test-shop-6668c.firebaseapp.com\",\n  projectId: \"test-shop-6668c\",\n  storageBucket: \"test-shop-6668c.appspot.com\",\n  messagingSenderId: \"634615670222\",\n  appId: \"1:634615670222:web:29da64eb32dc34fef4379f\"\n}; // Initialize Firebase // SDK (Developer Kit)\n\nconst firebaseApp = initializeApp(firebaseConfig); // initialzie a provider / provider ist also immer eine neue Instanz von googleauthprovider (hat constructor und benotigt Argumente)\n// googleAuthProvider ist eine Klasse, die connected mit googleAuth ist. Deswegen new Keyword für neue Instanz\n// Und manchmal müssen wir mehrer verschiedene Provider erstellen, um verschiedene Daten zu bearbeiteten\n// man könnte zum Beispiel für signInWithRedirect einen anderen Provider mitgeben\n\nconst provider = new GoogleAuthProvider(); // dann geben wir diesem Provider noch spezielle Instruktionen, wie er vorgehen soll / Ich denke mal, jeder User der dann den Provider nutzt, interagiert mit dieser überarbeiteteten\n// Version, da diese erst initialisiert wurde, jetzt angepasst und später aufgerufen wird\n\nprovider.setCustomParameters({\n  prompt: \"select_account\" // jedes Mal, wenn jemand mit dem Provider interagiert, soll er jedes mal seinen account auswählen müssen\n\n}); // Google will diese Einstellung/ Vorgehen und man muss es einfach wissen, dass man es so einstellen muss\n// diese authentification wird woanders eingebunden\n// Authentification Prozess ist immer gleich. Das ist keine Klasse, von der Unterschiedliche Objekte erstellt werden müssen\n// deswegen kein new Keyword\n\nexport const auth = getAuth(); // ebenso müssen wir die Signin Logik woanders einbinden (button in SignIn Sektion) und als Parameter bekommt er einmal die authentification und den Provider\n\nexport const signInWithGooglePopup = () => signInWithPopup(auth, provider); // Man braucht immer nur eine Authentification, egal für welchen Vorgang aber man könnte verschiedene Provider Konfiguraitionen für verschiedene Services benötigen\n// (   Deswegen bei getAuth() kein new keyword und bei    new GoogleAuthProvider() mit new Keyword   )\n// ab hier werden die Daten dann angelegt bzw in firestore gespeichert\n\nexport const db = getFirestore(); // die hier geschaffene Instanz gibt uns 1mal acces zur Database jedes mal um etwas zu ändern?\n// hier wollen wir die Daten, die wir von dem authentification service aus signIn Component zurückerhalten(nach sign in) übergeben\n// und dann inside firestore speichern\n\nexport const createUserDocumentFromAuth = async function (userAuth) {\n  let additionalInformation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // in additional information wird wegen unten genannt, der displayname übergeben {displayName: \"mike\"}\n  // prüfen, ob eine bestiimte Instanz vom document user bereits existiert (Referenz)\n  // die Methode doc() nimmt drei argumente:\n  // die Datenbank, die aufgerufen werden soll(firestore)\n  // wie die entsprechende collection heißt (der folder) hier: users\n  // der Unique identifier für den entsprechenden user (das document) -> hier übergeben wir aus dem auth service die \"uid\"\n  const userDocRef = doc(db, \"users\", userAuth.uid); // console.log(userDocRef)\n  // Bis hier hin, wird nach user login vom shop ein \"leerer\" Befehl mit user/userId an die Datenbank geschickt, weil noch nicht \n  // definiert wurde, wie die Daten verarbeitet werden sollen/ bzw. welche Daten abgefragt und gespeichert werden\n  // mit getDoc versucht man die Daten zu einem Document zu erfassen. Also übergeben wir dem die user data von firestore, vom user der sich gerade authentifiziert hat\n  // snapshot ist quasi die Dateien und ist auch ein SPEZIELLES OBJEKT\n\n  const userSnapshot = await getDoc(userDocRef);\n  console.log(userSnapshot);\n  console.log(userSnapshot.exists()); // false, weil in meiner firestore database noch kein Eintrag zu diesem user vorhanden ist\n  // now check if user Data exists\n  // create/ set the document with the data from userAuth in my collection\n\n  if (!userSnapshot.exists()) {\n    const {\n      displayName,\n      email\n    } = userAuth; // relevanten Daten aus der userAut response\n\n    const createdAt = new Date(); // aktuelles Datum erfassen\n\n    try {\n      await setDoc(userDocRef, {\n        // Daten in das Document auf firestore eintragen und dabei Folgende Konfigs beachten\n        displayName,\n        email,\n        createdAt,\n        ...additionalInformation // display name wird bisher nicht angezeigt, da google auth das keyword selbst belegt. daher wird dann der name in diesen additional information gespeichert\n\n      });\n    } catch (error) {\n      console.log(\"error creating the user\", error);\n    }\n  }\n\n  return userDocRef;\n}; // INTERFACE LAYER FUNCTIONS\n\nexport const createAuthUserWithEmailAndPassword = async (email, password) => {\n  if (!email || !password) return; // wenn weder email oder passwort agegeben ist, soll diese Funktion nicht ausgeführt werden (protect code)\n\n  return await createUserWithEmailAndPassword(auth, email, password);\n}; // Diese Helper Funktion ist für das log in \n\nexport const signInAuthUserWithEmailAndPassword = async (email, password) => {\n  if (!email || !password) return; // wenn weder email oder passwort agegeben ist, soll diese Funktion nicht ausgeführt werden (protect code)\n\n  return await signInWithEmailAndPassword(auth, email, password);\n};\nexport const signOutUser = async () => signOut(auth); // async weil wir abwarten wollen, was signOut für ein promise returned\n// a callback everytime i want to call when auth state changes\n\nexport const onAuthStateChangedListener = callback => onAuthStateChanged(auth, callback);","map":{"version":3,"sources":["/Users/Bronko/Desktop/capstone/theShop/src/utils/firebase/firebase.utils.js"],"names":["initializeApp","getAuth","signInWithRedirect","signInWithPopup","GoogleAuthProvider","signInWithEmailAndPassword","createUserWithEmailAndPassword","signOut","onAuthStateChanged","getFirestore","doc","getDoc","setDoc","firebaseConfig","apiKey","authDomain","projectId","storageBucket","messagingSenderId","appId","firebaseApp","provider","setCustomParameters","prompt","auth","signInWithGooglePopup","db","createUserDocumentFromAuth","userAuth","additionalInformation","userDocRef","uid","userSnapshot","console","log","exists","displayName","email","createdAt","Date","error","createAuthUserWithEmailAndPassword","password","signInAuthUserWithEmailAndPassword","signOutUser","onAuthStateChangedListener","callback"],"mappings":"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","sourcesContent":["import { initializeApp } from \"firebase/app\"; // um die app Instanz zu starten\n\n//importiere die authentification library von firebase --- wird für das google sign in benötigt (entweder per popup oder redirect)\nimport { getAuth, signInWithRedirect, signInWithPopup, GoogleAuthProvider, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged } from \"firebase/auth\"\n\nimport {\n    getFirestore,   // firestore instanz starten\n    doc,            // Zugriff auf document type in firebase (user)\n    getDoc,         // get document data in firebase (for each user)\n    setDoc          // set document data in firebase (for each user)\n} from \"firebase/firestore\";\n\n// Your web app's Firebase configuration von der Firebase Webseite. Das sind die Konfiguaraionsdaten zu diese speziellen Projekt\nconst firebaseConfig = {\n    apiKey: \"AIzaSyDiOjfAzd3SJXJvyGP2rhEb3oLWgC8Z94o\",\n    authDomain: \"test-shop-6668c.firebaseapp.com\",\n    projectId: \"test-shop-6668c\",\n    storageBucket: \"test-shop-6668c.appspot.com\",\n    messagingSenderId: \"634615670222\",\n    appId: \"1:634615670222:web:29da64eb32dc34fef4379f\"\n  };\n  \n  // Initialize Firebase // SDK (Developer Kit)\nconst firebaseApp = initializeApp(firebaseConfig);\n\n  // initialzie a provider / provider ist also immer eine neue Instanz von googleauthprovider (hat constructor und benotigt Argumente)\n  // googleAuthProvider ist eine Klasse, die connected mit googleAuth ist. Deswegen new Keyword für neue Instanz\n  // Und manchmal müssen wir mehrer verschiedene Provider erstellen, um verschiedene Daten zu bearbeiteten\n  // man könnte zum Beispiel für signInWithRedirect einen anderen Provider mitgeben\nconst provider = new GoogleAuthProvider();\n  // dann geben wir diesem Provider noch spezielle Instruktionen, wie er vorgehen soll / Ich denke mal, jeder User der dann den Provider nutzt, interagiert mit dieser überarbeiteteten\n  // Version, da diese erst initialisiert wurde, jetzt angepasst und später aufgerufen wird\nprovider.setCustomParameters({          \n    prompt: \"select_account\"             // jedes Mal, wenn jemand mit dem Provider interagiert, soll er jedes mal seinen account auswählen müssen\n});                                     // Google will diese Einstellung/ Vorgehen und man muss es einfach wissen, dass man es so einstellen muss\n\n\n\n// diese authentification wird woanders eingebunden\n// Authentification Prozess ist immer gleich. Das ist keine Klasse, von der Unterschiedliche Objekte erstellt werden müssen\n// deswegen kein new Keyword\nexport const auth = getAuth();\n\n// ebenso müssen wir die Signin Logik woanders einbinden (button in SignIn Sektion) und als Parameter bekommt er einmal die authentification und den Provider\nexport const signInWithGooglePopup = () => signInWithPopup(auth, provider);\n\n\n// Man braucht immer nur eine Authentification, egal für welchen Vorgang aber man könnte verschiedene Provider Konfiguraitionen für verschiedene Services benötigen\n    // (   Deswegen bei getAuth() kein new keyword und bei    new GoogleAuthProvider() mit new Keyword   )\n\n\n\n// ab hier werden die Daten dann angelegt bzw in firestore gespeichert\n\nexport const db = getFirestore()    // die hier geschaffene Instanz gibt uns 1mal acces zur Database jedes mal um etwas zu ändern?\n\n\n// hier wollen wir die Daten, die wir von dem authentification service aus signIn Component zurückerhalten(nach sign in) übergeben\n// und dann inside firestore speichern\nexport  const createUserDocumentFromAuth = async (userAuth, additionalInformation = {}) => {\n    // in additional information wird wegen unten genannt, der displayname übergeben {displayName: \"mike\"}\n\n    // prüfen, ob eine bestiimte Instanz vom document user bereits existiert (Referenz)\n    // die Methode doc() nimmt drei argumente:\n        // die Datenbank, die aufgerufen werden soll(firestore)\n        // wie die entsprechende collection heißt (der folder) hier: users\n        // der Unique identifier für den entsprechenden user (das document) -> hier übergeben wir aus dem auth service die \"uid\"\n    const userDocRef = doc(db, \"users\", userAuth.uid)\n    // console.log(userDocRef)\n    // Bis hier hin, wird nach user login vom shop ein \"leerer\" Befehl mit user/userId an die Datenbank geschickt, weil noch nicht \n    // definiert wurde, wie die Daten verarbeitet werden sollen/ bzw. welche Daten abgefragt und gespeichert werden\n\n    // mit getDoc versucht man die Daten zu einem Document zu erfassen. Also übergeben wir dem die user data von firestore, vom user der sich gerade authentifiziert hat\n    // snapshot ist quasi die Dateien und ist auch ein SPEZIELLES OBJEKT\n    const userSnapshot = await getDoc(userDocRef);\n    console.log(userSnapshot);\n    console.log(userSnapshot.exists()) // false, weil in meiner firestore database noch kein Eintrag zu diesem user vorhanden ist\n\n\n    // now check if user Data exists\n    // create/ set the document with the data from userAuth in my collection\n    if(!userSnapshot.exists()) {\n        const { displayName, email } = userAuth;    // relevanten Daten aus der userAut response\n        const createdAt = new Date();               // aktuelles Datum erfassen\n        \n        try {\n            await setDoc(userDocRef, {              // Daten in das Document auf firestore eintragen und dabei Folgende Konfigs beachten\n                displayName,\n                email,\n                createdAt,\n                ...additionalInformation            // display name wird bisher nicht angezeigt, da google auth das keyword selbst belegt. daher wird dann der name in diesen additional information gespeichert\n            });\n        } catch (error) {\n            console.log(\"error creating the user\", error);\n        }\n    }\n    return userDocRef;\n}\n\n// INTERFACE LAYER FUNCTIONS\n\nexport const createAuthUserWithEmailAndPassword = async (email, password) => {\n    if (!email || !password) return;        // wenn weder email oder passwort agegeben ist, soll diese Funktion nicht ausgeführt werden (protect code)\n\n    return await createUserWithEmailAndPassword(auth, email, password);\n}\n\n// Diese Helper Funktion ist für das log in \nexport const signInAuthUserWithEmailAndPassword = async (email, password) => {\n    if (!email || !password) return;        // wenn weder email oder passwort agegeben ist, soll diese Funktion nicht ausgeführt werden (protect code)\n\n    return await signInWithEmailAndPassword(auth, email, password);\n}\n\nexport const signOutUser = async () =>  signOut(auth);\n// async weil wir abwarten wollen, was signOut für ein promise returned\n\n\n// a callback everytime i want to call when auth state changes\nexport const onAuthStateChangedListener = (callback) => onAuthStateChanged(auth, callback);"]},"metadata":{},"sourceType":"module"}
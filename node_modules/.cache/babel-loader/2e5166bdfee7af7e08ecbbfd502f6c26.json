{"ast":null,"code":"import { initializeApp } from \"firebase/app\"; // um die app Instanz zu starten\n//importiere die authentification library von firebase --- wird für das google sign in benötigt (entweder per popup oder redirect)\n\nimport { getAuth, signInWithRedirect, signInWithPopup, GoogleAuthProvider, signInWithEmailAndPassword } from \"firebase/auth\";\nimport { getFirestore, // firestore instanz starten\ndoc, // Zugriff auf document type in firebase (user)\ngetDoc, // get document data in firebase (for each user)\nsetDoc // set document data in firebase (for each user)\n} from \"firebase/firestore\"; // Your web app's Firebase configuration von der Firebase Webseite. Das sind die Konfiguaraionsdaten zu diese speziellen Projekt\n\nconst firebaseConfig = {\n  apiKey: \"AIzaSyDiOjfAzd3SJXJvyGP2rhEb3oLWgC8Z94o\",\n  authDomain: \"test-shop-6668c.firebaseapp.com\",\n  projectId: \"test-shop-6668c\",\n  storageBucket: \"test-shop-6668c.appspot.com\",\n  messagingSenderId: \"634615670222\",\n  appId: \"1:634615670222:web:29da64eb32dc34fef4379f\"\n}; // Initialize Firebase // SDK (Developer Kit)\n\nconst firebaseApp = initializeApp(firebaseConfig); // initialzie a provider / provider ist also immer eine neue Instanz von googleauthprovider (hat constructor und benotigt Argumente)\n// googleAuthProvider ist eine Klasse, die connected mit googleAuth ist. Deswegen new Keyword für neue Instanz\n// Und manchmal müssen wir mehrer verschiedene Provider erstellen, um verschiedene Daten zu bearbeiteten\n// man könnte zum Beispiel für signInWithRedirect einen anderen Provider mitgeben\n\nconst provider = new GoogleAuthProvider(); // dann geben wir diesem Provider noch spezielle Instruktionen, wie er vorgehen soll / Ich denke mal, jeder User der dann den Provider nutzt, interagiert mit dieser überarbeiteteten\n// Version, da diese erst initialisiert wurde, jetzt angepasst und später aufgerufen wird\n\nprovider.setCustomParameters({\n  prompt: \"select_account\" // jedes Mal, wenn jemand mit dem Provider interagiert, soll er jedes mal seinen account auswählen müssen\n\n}); // Google will diese Einstellung/ Vorgehen und man muss es einfach wissen, dass man es so einstellen muss\n// diese authentification wird woanders eingebunden\n// Authentification Prozess ist immer gleich. Das ist keine Klasse, von der Unterschiedliche Objekte erstellt werden müssen\n// deswegen kein new Keyword\n\nexport const auth = getAuth(); // ebenso müssen wir die Signin Logik woanders einbinden (button in SignIn Sektion) und als Parameter bekommt er einmal die authentification und den Provider\n\nexport const signInWithGooglePopup = () => signInWithPopup(auth, provider); // Man braucht immer nur eine Authentification, egal für welchen Vorgang aber man könnte verschiedene Provider Konfiguraitionen für verschiedene Services benötigen\n// (   Deswegen bei getAuth() kein new keyword und bei    new GoogleAuthProvider() mit new Keyword   )\n// ab hier werden die Daten dann angelegt bzw in firestore gespeichert\n\nexport const db = getFirestore(); // die hier geschaffene Instanz gibt uns 1mal acces zur Database jedes mal um etwas zu ändern?\n// hier wollen wir die Daten, die wir von dem authentification service aus signIn Component zurückerhalten(nach sign in) übergeben\n// und dann inside firestore speichern\n\nexport const createUserDocumentFromAuth = async userAuth => {\n  // prüfen, ob eine bestiimte Instanz vom document user bereits existiert (Referenz)\n  // die Methode doc() nimmt drei argumente:\n  // die Datenbank, die aufgerufen werden soll(firestore)\n  // wie die entsprechende collection heißt (der folder) hier: users\n  // der Unique identifier für den entsprechenden user (das document) -> hier übergeben wir aus dem auth service die \"uid\"\n  const userDocRef = doc(db, \"users\", userAuth.uid);\n  console.log(userDocRef); // Bis hier hin, wird nach user login vom shop ein \"leerer\" Befehl mit user/userId an die Datenbank geschickt, weil noch nicht \n  // definiert wurde, wie die Daten verarbeitet werden sollen/ bzw. welche Daten abgefragt und gespeichert werden\n  // mit getDoc versucht man die Daten zu einem Document zu erfassen. Also übergeben wir dem die user data von firestore, vom user der sich gerade authentifiziert hat\n  // snapshot ist quasi die Dateien und ist auch ein SPEZIELLES OBJEKT\n\n  const userSnapshot = await getDoc(userDocRef);\n  console.log(userSnapshot);\n  console.log(userSnapshot.exists()); // false, weil in meiner firestore database noch kein Eintrag zu diesem user vorhanden ist\n  // now check if user Data exists\n  // create/ set the document with the data from userAuth in my collection\n\n  if (!userSnapshot.exists()) {\n    const {\n      displayName,\n      email\n    } = userAuth; // relevanten Daten aus der userAut response\n\n    const createdAt = new Date(); // aktuelles Datum erfassen\n\n    try {\n      await setDoc(userDocRef, {\n        // Daten in das Document auf firestore eintragen und dabei Folgende Konfigs beachten\n        displayName,\n        email,\n        createdAt\n      });\n    } catch (error) {\n      console.log(\"error creating the user\", error);\n    }\n  }\n\n  return userDocRef;\n};","map":{"version":3,"sources":["/Users/Bronko/Desktop/capstone/theShop/src/utils/firebase/firebase.utils.js"],"names":["initializeApp","getAuth","signInWithRedirect","signInWithPopup","GoogleAuthProvider","signInWithEmailAndPassword","getFirestore","doc","getDoc","setDoc","firebaseConfig","apiKey","authDomain","projectId","storageBucket","messagingSenderId","appId","firebaseApp","provider","setCustomParameters","prompt","auth","signInWithGooglePopup","db","createUserDocumentFromAuth","userAuth","userDocRef","uid","console","log","userSnapshot","exists","displayName","email","createdAt","Date","error"],"mappings":"AAAA,SAASA,aAAT,QAA8B,cAA9B,C,CAA8C;AAE9C;;AACA,SAASC,OAAT,EAAkBC,kBAAlB,EAAsCC,eAAtC,EAAuDC,kBAAvD,EAA2EC,0BAA3E,QAA6G,eAA7G;AAEA,SACIC,YADJ,EACoB;AAChBC,GAFJ,EAEoB;AAChBC,MAHJ,EAGoB;AAChBC,MAJJ,CAIoB;AAJpB,OAKO,oBALP,C,CAOA;;AACA,MAAMC,cAAc,GAAG;AACnBC,EAAAA,MAAM,EAAE,yCADW;AAEnBC,EAAAA,UAAU,EAAE,iCAFO;AAGnBC,EAAAA,SAAS,EAAE,iBAHQ;AAInBC,EAAAA,aAAa,EAAE,6BAJI;AAKnBC,EAAAA,iBAAiB,EAAE,cALA;AAMnBC,EAAAA,KAAK,EAAE;AANY,CAAvB,C,CASE;;AACF,MAAMC,WAAW,GAAGjB,aAAa,CAACU,cAAD,CAAjC,C,CAEE;AACA;AACA;AACA;;AACF,MAAMQ,QAAQ,GAAG,IAAId,kBAAJ,EAAjB,C,CACE;AACA;;AACFc,QAAQ,CAACC,mBAAT,CAA6B;AACzBC,EAAAA,MAAM,EAAE,gBADiB,CACY;;AADZ,CAA7B,E,CAEwC;AAIxC;AACA;AACA;;AACA,OAAO,MAAMC,IAAI,GAAGpB,OAAO,EAApB,C,CAEP;;AACA,OAAO,MAAMqB,qBAAqB,GAAG,MAAMnB,eAAe,CAACkB,IAAD,EAAOH,QAAP,CAAnD,C,CAGP;AACI;AAIJ;;AAEA,OAAO,MAAMK,EAAE,GAAGjB,YAAY,EAAvB,C,CAA6B;AAGpC;AACA;;AACA,OAAQ,MAAMkB,0BAA0B,GAAG,MAAOC,QAAP,IAAoB;AAE3D;AACA;AACI;AACA;AACA;AACJ,QAAMC,UAAU,GAAGnB,GAAG,CAACgB,EAAD,EAAK,OAAL,EAAcE,QAAQ,CAACE,GAAvB,CAAtB;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYH,UAAZ,EAR2D,CAS3D;AACA;AAEA;AACA;;AACA,QAAMI,YAAY,GAAG,MAAMtB,MAAM,CAACkB,UAAD,CAAjC;AACAE,EAAAA,OAAO,CAACC,GAAR,CAAYC,YAAZ;AACAF,EAAAA,OAAO,CAACC,GAAR,CAAYC,YAAY,CAACC,MAAb,EAAZ,EAhB2D,CAgBxB;AAGnC;AACA;;AACA,MAAG,CAACD,YAAY,CAACC,MAAb,EAAJ,EAA2B;AACvB,UAAM;AAAEC,MAAAA,WAAF;AAAeC,MAAAA;AAAf,QAAyBR,QAA/B,CADuB,CACqB;;AAC5C,UAAMS,SAAS,GAAG,IAAIC,IAAJ,EAAlB,CAFuB,CAEqB;;AAE5C,QAAI;AACA,YAAM1B,MAAM,CAACiB,UAAD,EAAa;AAAe;AACpCM,QAAAA,WADqB;AAErBC,QAAAA,KAFqB;AAGrBC,QAAAA;AAHqB,OAAb,CAAZ;AAKH,KAND,CAME,OAAOE,KAAP,EAAc;AACZR,MAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ,EAAuCO,KAAvC;AACH;AACJ;;AACD,SAAOV,UAAP;AAEH,CArCO","sourcesContent":["import { initializeApp } from \"firebase/app\"; // um die app Instanz zu starten\n\n//importiere die authentification library von firebase --- wird für das google sign in benötigt (entweder per popup oder redirect)\nimport { getAuth, signInWithRedirect, signInWithPopup, GoogleAuthProvider, signInWithEmailAndPassword } from \"firebase/auth\"\n\nimport {\n    getFirestore,   // firestore instanz starten\n    doc,            // Zugriff auf document type in firebase (user)\n    getDoc,         // get document data in firebase (for each user)\n    setDoc          // set document data in firebase (for each user)\n} from \"firebase/firestore\";\n\n// Your web app's Firebase configuration von der Firebase Webseite. Das sind die Konfiguaraionsdaten zu diese speziellen Projekt\nconst firebaseConfig = {\n    apiKey: \"AIzaSyDiOjfAzd3SJXJvyGP2rhEb3oLWgC8Z94o\",\n    authDomain: \"test-shop-6668c.firebaseapp.com\",\n    projectId: \"test-shop-6668c\",\n    storageBucket: \"test-shop-6668c.appspot.com\",\n    messagingSenderId: \"634615670222\",\n    appId: \"1:634615670222:web:29da64eb32dc34fef4379f\"\n  };\n  \n  // Initialize Firebase // SDK (Developer Kit)\nconst firebaseApp = initializeApp(firebaseConfig);\n\n  // initialzie a provider / provider ist also immer eine neue Instanz von googleauthprovider (hat constructor und benotigt Argumente)\n  // googleAuthProvider ist eine Klasse, die connected mit googleAuth ist. Deswegen new Keyword für neue Instanz\n  // Und manchmal müssen wir mehrer verschiedene Provider erstellen, um verschiedene Daten zu bearbeiteten\n  // man könnte zum Beispiel für signInWithRedirect einen anderen Provider mitgeben\nconst provider = new GoogleAuthProvider();\n  // dann geben wir diesem Provider noch spezielle Instruktionen, wie er vorgehen soll / Ich denke mal, jeder User der dann den Provider nutzt, interagiert mit dieser überarbeiteteten\n  // Version, da diese erst initialisiert wurde, jetzt angepasst und später aufgerufen wird\nprovider.setCustomParameters({          \n    prompt: \"select_account\"             // jedes Mal, wenn jemand mit dem Provider interagiert, soll er jedes mal seinen account auswählen müssen\n});                                     // Google will diese Einstellung/ Vorgehen und man muss es einfach wissen, dass man es so einstellen muss\n\n\n\n// diese authentification wird woanders eingebunden\n// Authentification Prozess ist immer gleich. Das ist keine Klasse, von der Unterschiedliche Objekte erstellt werden müssen\n// deswegen kein new Keyword\nexport const auth = getAuth();\n\n// ebenso müssen wir die Signin Logik woanders einbinden (button in SignIn Sektion) und als Parameter bekommt er einmal die authentification und den Provider\nexport const signInWithGooglePopup = () => signInWithPopup(auth, provider);\n\n\n// Man braucht immer nur eine Authentification, egal für welchen Vorgang aber man könnte verschiedene Provider Konfiguraitionen für verschiedene Services benötigen\n    // (   Deswegen bei getAuth() kein new keyword und bei    new GoogleAuthProvider() mit new Keyword   )\n\n\n\n// ab hier werden die Daten dann angelegt bzw in firestore gespeichert\n\nexport const db = getFirestore()    // die hier geschaffene Instanz gibt uns 1mal acces zur Database jedes mal um etwas zu ändern?\n\n\n// hier wollen wir die Daten, die wir von dem authentification service aus signIn Component zurückerhalten(nach sign in) übergeben\n// und dann inside firestore speichern\nexport  const createUserDocumentFromAuth = async (userAuth) => {\n\n    // prüfen, ob eine bestiimte Instanz vom document user bereits existiert (Referenz)\n    // die Methode doc() nimmt drei argumente:\n        // die Datenbank, die aufgerufen werden soll(firestore)\n        // wie die entsprechende collection heißt (der folder) hier: users\n        // der Unique identifier für den entsprechenden user (das document) -> hier übergeben wir aus dem auth service die \"uid\"\n    const userDocRef = doc(db, \"users\", userAuth.uid)\n    console.log(userDocRef)\n    // Bis hier hin, wird nach user login vom shop ein \"leerer\" Befehl mit user/userId an die Datenbank geschickt, weil noch nicht \n    // definiert wurde, wie die Daten verarbeitet werden sollen/ bzw. welche Daten abgefragt und gespeichert werden\n\n    // mit getDoc versucht man die Daten zu einem Document zu erfassen. Also übergeben wir dem die user data von firestore, vom user der sich gerade authentifiziert hat\n    // snapshot ist quasi die Dateien und ist auch ein SPEZIELLES OBJEKT\n    const userSnapshot = await getDoc(userDocRef);\n    console.log(userSnapshot);\n    console.log(userSnapshot.exists()) // false, weil in meiner firestore database noch kein Eintrag zu diesem user vorhanden ist\n\n\n    // now check if user Data exists\n    // create/ set the document with the data from userAuth in my collection\n    if(!userSnapshot.exists()) {\n        const { displayName, email } = userAuth;    // relevanten Daten aus der userAut response\n        const createdAt = new Date();               // aktuelles Datum erfassen\n        \n        try {\n            await setDoc(userDocRef, {              // Daten in das Document auf firestore eintragen und dabei Folgende Konfigs beachten\n                displayName,\n                email,\n                createdAt\n            });\n        } catch (error) {\n            console.log(\"error creating the user\", error);\n        }\n    }\n    return userDocRef;\n\n}"]},"metadata":{},"sourceType":"module"}